<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>粒子汇聚爱心轮廓与文字</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <canvas id="particleCanvas"></canvas>

    <script>
        // 获取画布并设置尺寸
        const canvas = document.getElementById('particleCanvas');
        const ctx = canvas.getContext('2d');

        // 设置画布尺寸为窗口大小
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // 颜色方案
        const COLORS = [
            [255, 99, 71], [255, 165, 0], [255, 105, 97],
            [255, 182, 193], [255, 20, 147], [138, 43, 226]
        ];

        // 粒子类
        class Particle {
            constructor(phase = 0) {
                // 初始位置 - 从屏幕边缘随机生成
                const edge = ['top', 'bottom', 'left', 'right'][Math.floor(Math.random() * 4)];
                if (edge === 'top') {
                    this.x = Math.random() * canvas.width;
                    this.y = 0;
                } else if (edge === 'bottom') {
                    this.x = Math.random() * canvas.width;
                    this.y = canvas.height;
                } else if (edge === 'left') {
                    this.x = 0;
                    this.y = Math.random() * canvas.height;
                } else {
                    this.x = canvas.width;
                    this.y = Math.random() * canvas.height;
                }

                // 粒子属性
                this.size = 1.8 + Math.random() * 1.2; // 1.8-3像素
                this.color = COLORS[Math.floor(Math.random() * COLORS.length)];
                this.speed = 1.2 + Math.random() * 2;
                this.phase = phase;
                this.targetIdx = 0;
                this.alpha = 255;
                this.arrived = false;

                // 初始分配目标点
                const targetPoints = phase === 0 ? lovePoints : textPoints;
                this.targetIdx = Math.floor(Math.random() * targetPoints.length);
            }

            // 更新位置
            update(lovePoints, textPoints) {
                const targetPoints = this.phase === 0 ? lovePoints : textPoints;
                if (this.targetIdx >= targetPoints.length) {
                    this.targetIdx = Math.floor(Math.random() * targetPoints.length);
                }

                const [targetX, targetY] = targetPoints[this.targetIdx];
                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.hypot(dx, dy);

                if (distance < this.speed) {
                    this.x = targetX;
                    this.y = targetY;
                    this.arrived = true;
                    // 轻微抖动
                    if (Math.random() < 0.1) {
                        this.x += (Math.random() - 0.5) * 2;
                        this.y += (Math.random() - 0.5) * 2;
                    }
                } else {
                    this.x += (dx / distance) * this.speed;
                    this.y += (dy / distance) * this.speed;
                }

                return true;
            }

            // 绘制粒子
            draw() {
                if (this.arrived) {
                    // 绘制光晕
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${this.color[0]}, ${this.color[1]}, ${this.color[2]}, 0.15)`;
                    ctx.fill();
                }

                // 绘制粒子本身
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = `rgb(${this.color[0]}, ${this.color[1]}, ${this.color[2]})`;
                ctx.fill();
            }
        }

        // 生成爱心轮廓点（只保留轮廓，移除内部点）
        function generateLovePoints() {
            const points = [];
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2 - 80;
            const scale = 16;

            // 生成密集的爱心轮廓点（增加角度采样密度）
            for (let angle = 0; angle < 360; angle += 0.5) {  // 每0.5度取一个点，使轮廓更平滑
                const t = angle * Math.PI / 180;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

                points.push([centerX + x * scale, centerY + y * scale]);
            }

            // 添加一些额外的轮廓点，确保线条更连续
            for (let i = 0; i < 500; i++) {
                const angle = Math.random() * 360;
                const t = angle * Math.PI / 180;
                const x = 16 * Math.pow(Math.sin(t), 3);
                const y = -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));

                // 微小的随机偏移，使轮廓更自然
                const jitter = (Math.random() - 0.5) * 2;
                points.push([centerX + x * scale + jitter, centerY + y * scale + jitter]);
            }

            return points;
        }

        // 生成文字形状的点
        function generateTextPoints() {
            const points = [];
            const text = "珂珂永远开心";
            const charSpacing = 160;
            const startX = canvas.width / 2 - (charSpacing * (text.length - 1)) / 2;
            const yPos = canvas.height / 2 + 50;

            // 创建一个临时画布用于文字采样
            const textCanvas = document.createElement('canvas');
            const textCtx = textCanvas.getContext('2d');
            textCanvas.width = canvas.width;
            textCanvas.height = canvas.height;

            // 绘制文字到临时画布
            textCtx.font = "bold 120px 'SimHei', 'Microsoft YaHei', sans-serif";
            textCtx.textAlign = 'center';
            textCtx.textBaseline = 'middle';
            textCtx.fillStyle = 'white';

            for (let i = 0; i < text.length; i++) {
                const charX = startX + i * charSpacing;
                textCtx.fillText(text[i], charX, yPos);
            }

            // 从临时画布采样点
            const imageData = textCtx.getImageData(0, 0, canvas.width, canvas.height);
            const pixelData = imageData.data;

            // 每隔2像素采样一次
            for (let y = 0; y < canvas.height; y += 2) {
                for (let x = 0; x < canvas.width; x += 2) {
                    const index = (y * canvas.width + x) * 4;
                    if (pixelData[index + 3] > 100) { // 检查alpha值
                        points.push([x, y]);
                    }
                }
            }

            // 补充内部点使文字更饱满
            for (let i = 0; i < text.length; i++) {
                const charX = startX + i * charSpacing;
                for (let j = 0; j < 250; j++) {
                    const x = charX - 50 + Math.random() * 100;
                    const y = yPos - 50 + Math.random() * 100;
                    points.push([x, y]);
                }
            }

            return points;
        }

        // 初始化点集合
        let lovePoints = generateLovePoints();
        let textPoints = generateTextPoints();

        // 监听窗口大小变化，重新生成点
        window.addEventListener('resize', () => {
            lovePoints = generateLovePoints();
            textPoints = generateTextPoints();
        });

        // 创建粒子
        let particles = [];
        for (let i = 0; i < 3000; i++) {
            particles.push(new Particle());
        }

        // 动画状态变量
        let bgAlpha = 0;
        let phase = 0; // 0: 爱心, 1: 文字
        let phaseTimer = 0;

        // 动画循环
        function animate() {
            requestAnimationFrame(animate);

            phaseTimer++;

            // 绘制背景
            ctx.fillStyle = `rgba(0, 0, 0, ${bgAlpha / 255})`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 逐渐增加背景不透明度
            if (bgAlpha < 230) {
                bgAlpha += 1;
            }

            // 7秒(420帧)后切换到文字
            if (phaseTimer > 420 && phase === 0) {
                phase = 1;
                particles.forEach(p => {
                    p.phase = 1;
                    p.arrived = false;
                    p.targetIdx = Math.floor(Math.random() * textPoints.length);
                });
            }

            // 更新和绘制所有粒子
            particles.forEach(p => {
                p.update(lovePoints, textPoints);
                p.draw();
            });

            // 随机添加新粒子
            if (Math.random() < 0.5) {
                const newParticle = new Particle(phase);
                particles.push(newParticle);
                // 限制最大粒子数量
                if (particles.length > 4000) {
                    particles.shift();
                }
            }
        }

        // 开始动画
        animate();
    </script>
</body>
</html>